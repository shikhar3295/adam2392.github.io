<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Adam Li - Machine Learning</title><link href="/" rel="alternate"></link><link href="/feeds/machine-learning.atom.xml" rel="self"></link><id>/</id><updated>2019-06-18T00:00:00-04:00</updated><entry><title>Linear Gaussian Models</title><link href="/blog/2019/06/gaussian-generative-models/" rel="alternate"></link><published>2019-06-18T00:00:00-04:00</published><updated>2019-06-18T00:00:00-04:00</updated><author><name>Adam Li</name></author><id>tag:None,2019-06-18:/blog/2019/06/gaussian-generative-models/</id><summary type="html">&lt;p&gt;An overview of linear gaussian models and how in general, they fall under the learning procedure (system idenfitication) of Expectation-Maximization.&lt;/p&gt;</summary><content type="html">&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
&lt;li&gt;Background&lt;/li&gt;
&lt;li&gt;Methods&lt;ul&gt;
&lt;li&gt;Most General Linear Gaussian Model&lt;/li&gt;
&lt;li&gt;General Expectation Maximization&lt;/li&gt;
&lt;li&gt;Kalman Filter/Smoothing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Important Models And Connections With Control Theory&lt;ul&gt;
&lt;li&gt;Static Models (i.e. time is not a factor)&lt;ul&gt;
&lt;li&gt;Continuous State&lt;/li&gt;
&lt;li&gt;Discrete State&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dynamical Models (i.e. time is a factor)&lt;ul&gt;
&lt;li&gt;Continuous State - Kalman Filter Models&lt;/li&gt;
&lt;li&gt;Discrete State - Hidden Markov Models&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-Gaussian Models (i.e. noise terms are no longer normally distributed)&lt;/li&gt;
&lt;li&gt;Control Theory Type Problems&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Conclusions&lt;/li&gt;
&lt;li&gt;References:&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /MarkdownTOC --&gt;

&lt;h1&gt;Background&lt;/h1&gt;
&lt;p&gt;Recently, I re-read this 1999 paper on Linear Gaussian models and I am pretty amazed at how deep this paper is in unifying the different common data analysis methods and linear models under one framework. We think of principal component analysis (PCA), or Gaussian mixture models (GMM), or Kalman filter models (KF) all as disparate ways to model data, but this review is able to bring them under the umbrella of the Expectation Maximization (EM). I wanted to highlight for myself (and anyone reading) the key high level concepts and insights and also extend these to talk about control systems.&lt;/p&gt;
&lt;p&gt;At a very simplifying level, linear gaussian models are heavily used in all branches of engineering from control systems, to data analysis. Expectation maximization is an iterative learning algorithm for learning some optimal parameters in a probabilistic model.&lt;/p&gt;
&lt;h1&gt;Methods&lt;/h1&gt;
&lt;h2&gt;Most General Linear Gaussian Model&lt;/h2&gt;
&lt;p&gt;Here is the most general form of the linear latent state-space model.&lt;/p&gt;
&lt;div class="math"&gt;$$\dot{x}(t) = Ax(t) + Bu(t) + w$$&lt;/div&gt;
&lt;div class="math"&gt;$$y(t) = Cx(t) + Du(t) + v$$&lt;/div&gt;
&lt;p&gt;where: &lt;span class="math"&gt;\(w \approx N(0,Q)\)&lt;/span&gt; and &lt;span class="math"&gt;\(v \approx N(0,R)\)&lt;/span&gt; are the state and output noise terms that we assume to be normally distributed (i.e. Gaussian).&lt;/p&gt;
&lt;p&gt;The dimensionality of the terms are:
&lt;em&gt; &lt;span class="math"&gt;\(x, w \in R^{n}\)&lt;/span&gt;
&lt;/em&gt; &lt;span class="math"&gt;\(y, v \in R^{p}\)&lt;/span&gt;
* &lt;span class="math"&gt;\(u \in R^{k}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Some jargon for folks:
&lt;em&gt; x is the state variable, generally considered "hidden", or part of the "latent space" (i.e. some subspace of your data that you don't know)
&lt;/em&gt; y is the observation variable, generally considered measured, or observed (i.e. signals in your data)
&lt;em&gt; u is our control signal, that we input
&lt;/em&gt; A is our state transition matrix governing how states change 
&lt;em&gt; B is our control matrix
&lt;/em&gt; C is our observation matrix
&lt;em&gt; D is our feedthrough matrix
&lt;/em&gt; w and v are our random variable noise terms that we may (sometimes) assume Normally distributed&lt;/p&gt;
&lt;p&gt;Then the A, B, C, D matrices have their respecting dimensionality. In general, we assume y is observed and measured.&lt;/p&gt;
&lt;h2&gt;General Expectation Maximization&lt;/h2&gt;
&lt;p&gt;The general expectation maximization boils down to two distinct steps: 1) Computing the expecation under a certain generative model (i.e. computing the expected states and covariances) and 2) Maximizing the likelihood given the states (i.e. computing the optimal parameters). In the general Gaussian model, these parameters are &lt;span class="math"&gt;\(\theta = \{A, C, B, D, Q, R\}\)&lt;/span&gt;. &lt;/p&gt;
&lt;h2&gt;Kalman Filter/Smoothing&lt;/h2&gt;
&lt;p&gt;The general Kalman filter assumes Gaussian noise, which we have here. Filtering is the problem of predicting the state &lt;span class="math"&gt;\(x(t)\)&lt;/span&gt; given all the observations up to time t. Smoothing is the problem of predicting the state &lt;span class="math"&gt;\(x(t)\)&lt;/span&gt; given all the observations we have (i.e. over entire window of observation of length T).&lt;/p&gt;
&lt;h1&gt;Important Models And Connections With Control Theory&lt;/h1&gt;
&lt;h2&gt;Static Models (i.e. time is not a factor)&lt;/h2&gt;
&lt;p&gt;Here, we are dealing with just data points (i.e. sets of x's, y's), so there is no notion of time dependency. This simplifies the general model, so that A = 0. &lt;/p&gt;
&lt;p&gt;General inference on model:&lt;/p&gt;
&lt;div class="math"&gt;$$P(x | y) = \frac{P(y|x)P(x)}{P(y)} = \frac{N(Cx, R) N(0, I)}{N(0, CC^T + R)}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(x|y) = N(\beta y, I - \beta C), \ \beta=C^T(CC^T + R)^{-1}$$&lt;/div&gt;
&lt;h3&gt;Continuous State&lt;/h3&gt;
&lt;p&gt;Here, we presume that the state space is continuous (i.e. x is a continuous variable).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(Sensible) Principal Component Analysis (PCA)
PCA is probably one of the most common dimensionality reduction techniques, which at the end of the day (for you lin alg folks) boils down to Singular Value Decomposition (SVD). Here we assume the following:&lt;/li&gt;
&lt;li&gt;the observation noise R is a multiple of the identity matrix (i.e. &lt;span class="math"&gt;\(R=\alpha I\)&lt;/span&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that because R is not 0, then we have some noise in the state variables, so this is very similar to probabilistic PCA. &lt;/p&gt;
&lt;p&gt;When &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; goes to 0, then the noise on the states goes to 0, while Q is still finite. This means that the only noise we assume in our model comes from our observations of the data. A naive approach would simply take the observed covariance matrix of our data, apply SVD to obtain the singular vector matrices and the singular values. The columns of C then are the principle components of PCA. The values of our latent space vector x are the principle values (i.e. singular values of our covariance matrix).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Maximum Likelihood Factor Analysis
In factor analysis, we assume the following:&lt;/li&gt;
&lt;li&gt;that the observation covariance matrix, R, is diagonal&lt;/li&gt;
&lt;li&gt;state noise Q is the identity matrix &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;X are considered the factors, and the key assumption assuming R is diagonal means that the model wants to put all the covariance structure in our observed data (i.e. y variables) into the unique coordinates of R. Note that if R is diagonal, then the off-diagonals (i.e. the covariances) are equal to 0. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Summary
In both static modeling procedures, where we assume our latent space and observations are static, we can solve them using EM by using the general inference equations described above for the static model. P(x|y) gives you the inference estimates of states (i.e. x) for a given set of parameters (in this case: C and R). Then for a given set of states (i.e. x), we can maximize wrt the log-likelihood of our model to recover new estimates of C and R. This is the EM algorithm! &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Quite fascinating that they wrapped this under one umbrella when most people normally look at solving for example PCA using SVD.&lt;/p&gt;
&lt;h3&gt;Discrete State&lt;/h3&gt;
&lt;p&gt;Here, we presume x is a discrete variable.
1. Gaussian Mixture Models
If x is a discrete probability distribution controlled by the distribution of the noise, w. The mean &lt;span class="math"&gt;\(\mu\)&lt;/span&gt; and covariance Q parametrize the distribution of x. Now x is modeled by:&lt;/p&gt;
&lt;div class="math"&gt;$$x = WTA(w)$$&lt;/div&gt;
&lt;p&gt;where WTA is the winner take all function applied to the vector w, so x becomes a unit vector of size n. Now the interpretation of x is the mixture weights (i.e. how much each data point y belongs to each cluster). The columns of matrix C represent the cluster means. This is solved via EM also.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Vector Quantization (K-means) Models
When the observation noise approaches 0 (i.e. R approaches 0), then we arrive at the k-means algorithm formulation, which can be solved via EM also. So now, P(x|y) is a single point, since there is no noise in the y term, and it is all governed by the noise in the k clusters defined in the state term. &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Dynamical Models (i.e. time is a factor)&lt;/h2&gt;
&lt;p&gt;Here, we now deal with the fact that time is a factor in our model. So A is no longer the 0 matrix. &lt;/p&gt;
&lt;h3&gt;Continuous State - Kalman Filter Models&lt;/h3&gt;
&lt;p&gt;The model is generated according to the general model with the noise terms all being independently and identically distributed. This is just solved via the Kalman filter and smoothing algorithms.&lt;/p&gt;
&lt;p&gt;If all parameters are known, can employ a Maximum Likelihood approach to estimate the states.&lt;/p&gt;
&lt;p&gt;If the parameters are unknown, then EM can be used to iterate on the parameters.&lt;/p&gt;
&lt;h3&gt;Discrete State - Hidden Markov Models&lt;/h3&gt;
&lt;p&gt;Now, we consider when the states are discrete, which lead to Hidden Markov Models. The model for the states is:&lt;/p&gt;
&lt;div class="math"&gt;$$x(t+1) = WTA(Ax(t)+w)$$&lt;/div&gt;
&lt;p&gt;Here, if we constrain Q to be the identity matrix, then it will have the same covariances for all Gaussians. With traditional Hidden Markov models, we usually define a state transition matrix (e.g. normalized columns), which defines how probable different state transitions are from an initial state. Solving for the most likely state sequence employs the famous Viterbi algorithm. Solving the filtering and smoothing problems, then employ EM traditionally.&lt;/p&gt;
&lt;h2&gt;Non-Gaussian Models (i.e. noise terms are no longer normally distributed)&lt;/h2&gt;
&lt;p&gt;This results in a famous class of algorithm known as Independent Component Analaysis. This is a generalization of the PCA. Here, we have a nonlinearity applied to the state model:&lt;/p&gt;
&lt;div class="math"&gt;$$x = g(w)$$&lt;/div&gt;
&lt;p&gt;This converts a Gaussian prior (i.e. noise variable w) into a non-Gaussian prior for the state variable x. Now, x is considered our "blind sources" and y is our observed data. In classical ICA, R is assumed to be infinitesimal, and C is square and full-rank. C is considered a "mixing matrix", that is how to mix the sources to "recover" our observed data.&lt;/p&gt;
&lt;h2&gt;Control Theory Type Problems&lt;/h2&gt;
&lt;p&gt;In control theory and linear systems, we are generally interested in the following problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Given the general model and outputs measured y, how do we estimate a control input u(t) that controls the dynamics of the state? That is, how do we control the eigenvalues of the system? &lt;ul&gt;
&lt;li&gt;This results in things like state-feedback and the notion of controllability.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Given the general model, how can we estimate the values of the states if we know the rest of the parameters (A, B, C, D)?&lt;ul&gt;
&lt;li&gt;This results in observers and the notion of observability.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Given the general model, how can we estimate an optimal u(t) that follows some constraints and minimizes some cost functional on u? (e.g. constraint on the magnitude of u, or the sparseness of u, etc.)&lt;ul&gt;
&lt;li&gt;This is known as optimal control. It can be deterministic, or stochastic. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that the Kalman filter/smoothing procedure is an optimal observer under Gaussian noise assumptions. The EM algorithm can be used in general in conjunction with Kalman filter/smoothing to estimate the parameters (A, B, C, D).&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;In this post, I attempt to summarize some of the main points in the Roweis paper that I thought were relevant to someone with knowledge in Linear Algebra, Probability &amp;amp; Statistics and Linear Dynamical Systems. The nice thing is that all these very common algorithms and methods can be framed using Expectation Maximization. This point of view links together control theory, linear dynamical systems and machine learning. It points to how general linear Gaussian models are and how general Expectation Maximization is. &lt;/p&gt;
&lt;h1&gt;References:&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Roweis S. et al. "A Unifying Review of Linear Gaussian Models".http://mlg.eng.cam.ac.uk/zoubin/papers/lds.pdf&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="phd"></category><category term="machine learning"></category></entry></feed>